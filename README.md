# TRACOParser

Python (ver. 3.8+) tool that parses output from TRACO/PLUTO and generates CUDA.


## Structure
This section provides theoretical information about structre of modules used in this Parser. 



## Examples
Firstly, lets see how we run the parser. Change your directory to *(...)\TRACOParser\\*. Make sure that inside main.py you run only *test_parser()* so comment out __main__ function. As a first example, we will test file *Examples/example1.c*. Run the code below:
 ```python
python main.py -i Examples/example1.c
```

For the reference, file example1.c looks as follows: 

![Example 1](https://github.com/PrzemyslawSamsel/TRACOParser/blob/master/img/Example_1_TRACO.png)



Whereas output generated by the parser is presented below:

[Output of example1.c]: https://github.com/PrzemyslawSamsel/TRACOParser/blob/master/img/Example_1_OUT.png

Test parser function, which we use in this example, looks as follows:

[Test parser]: https://github.com/PrzemyslawSamsel/TRACOParser/blob/master/img/test_parser.png

What the *test_parser()* function does, it firstly creates new *Parser* object (passing name of the file to parse). Then it calls Parser's *readfile()* function, which fills Parser's attribute called *file_structure*. This attribute is actually returned by that, but can also be accessed from the class instance as well. *file_structure* is a Python namedtuple, containing the following fields: 

+ *variables*, a dictionary containing info about defined variables
+ *instructions*, a list of instructions executed by the program

So far, so good. Finally, the *test_parser()* function just iterates over the list of instructions and displays information about each one of them. Basically, we check each instruction using *isinstance(object, mainclass)* to check whether its one of two main cases: 


+ Constructions - discussed in **Structure** section in more detail. In short, it describes complex instruction such as for loop, if statement etc. It has a field of type namedtupe, and a list of underlying instructions;
+ simple Python dict - this is a way of representing simple arithmetic operations, assignment to a variable, etc;


In the example, first parsed instruction is **pragma** which sets first spotted 'FOR' as parallel. Next line, we have Constructions object. We see the flag *is_parallel* set to true, and a list of instructions which contains another 'FOR'. We get inside its instructions field and print out another 'FOR' specifics and instructions list, which in turn has Python dict as only element (variable assignment). 

We'll skip example2.c and run the last example: 

[Example 3]: https://github.com/PrzemyslawSamsel/TRACOParser/blob/master/img/Example_1_TRACO.png

The output from this example is as follows: 

[Example 3 Output]: https://github.com/PrzemyslawSamsel/TRACOParser/blob/master/img/Example_1_OUT.png


This example contains a multiline 'FOR' which is defined using curly '{}' brackets. Reading the instructions, first one is **pragma**. After that, we find first 'FOR' which has also some instructions inside, first of which is variable assignment (dict), and the other one is another 'FOR' (Constructions object).  As we access the other FOR's instructions list, we see there is another assignment. 

To see it from another perspective, we will now run the interactive console and then inside it import module and do the same job manually:
 ```python
$ python
Python 3.8.2 (tags/v3.8.2:7b3ab59, Feb 25 2020, 23:03:10) [MSC v.1916 64 bit (AMD64)] on win32
Type "help", "copyright", "credits" or "license" for more information.
>>>
>>> from Parser.Parser import Parser
>>> ps = Parser('Examples\example3.c')
>>>
>>> ps.readfile()
```
As discussed previously, *readfile()* returns a parser file structure: 
 ```python
 File_struct(variables={'N': 5, 'A': {'name': 'A', 'size': (5, 5)}}, instructions=['pragma', <Parser.Constructions.Constructions object at 0x000001A1D41A9EE0>])
```
We see two variable declared in a file - 'N' of value 5 and an array ('A') of size [5][5]. As for this part of the task, these variable are only hardcoded for the testing purposes, but this will change in the future and so will this section. As for now, we got also some instructions in the other field of file structure. First one is well known (**pragma**), but what is the other? Lets check this out using old good friend *dir()* which tells us some info about given object:
```python
>>> dir(ps.file_structure.instructions[1])
['Constr', '__class__', '__delattr__', '__dict__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__le__', '__lt__', '__module__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__', 'eval_for', 'eval_pragma', 'method']
```
As we can see, a lot of python dunder methods, which aren't particularly interesting in our case. We see some objects like 'eval_for', 'eval_pragma', or 'method' but let's just leave them for now (they are discussed in **Structure** section). What should catch your attention is 'Constr'. What it is? let's see: 
```python
>>> ps.file_structure.instructions[1].Constr
for_n(init={'name': 'i', 'value': 0}, end_condition={'var': 'i', 'value': 4}, increment={'var': 'i', 'inc': 1}, instructions=[{'var': 'A', 'index': '[i][j]', 'val': '5', 'original_line': 'A[i][j] = 5;'}, <Parser.Constructions.Constructions object at 0x000001A1D41A9F40>], is_parallel=True, original_line='for(i=0; i<N; i++)')
>>>
```
We see a lot of interesting information going on here, don't we? We know now that we deal with 'FOR' instruction, we know its parameters, and we know a list of instructions that are being executed inside this FOR. Apparently, in this case its an variable assignment (Python dict), and next element in the list of instructions is another Constructions object. We will leave exploring that object to the reader. Lastly, there are Python functions which will help you determining type of object you deal with. Let's see'em in action: 
```python
>>> from Parser.Constructions import Constructions
>>> isinstance(ps.file_structure.instructions[1], Constructions)
True
>>>
>>> hasattr(ps.file_structure.instructions[1], 'Constr')
True
>>>
```
This is just to help the reader in iterating over the *file_structure* generated by **Parser**. 
